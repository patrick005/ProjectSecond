
# TUI 기반 자이로센서 격투 게임 프로젝트 계획서

## 1. 프로젝트 개요

본 프로젝트는 Raspberry Pi와 ESP8266을 기반으로 텍스트 기반 사용자 인터페이스(TUI) 환경에서 동작하는 1대1 격투 게임을 구현하는 것입니다.  
서버는 클라이언트 연결 및 게임 로직을 처리하고, 클라이언트는 자이로센서를 통해 수집한 데이터를 서버로 전송하여 게임을 조작합니다.  
서버-클라이언트 간 통신은 TCP/IP 기반 ZeroMQ를 사용하며, 프로세스는 C, C++, Python으로 분산 구성합니다.

## 2. 시스템 구성 및 기술 스택

| 구성 요소     | 역할                              | 사용 언어   | 주요 라이브러리/도구         |
|--------------|-----------------------------------|-------------|-------------------------------|
| Raspberry Pi | 서버 역할, 게임 처리 및 TUI 출력  | Python      | `zmq`, `sqlite3`, `curses`    |
| ESP8266      | 클라이언트 역할, 센서 데이터 송신 | C / C++     | `ESP8266WiFi`, `Wire.h`       |
| 데이터베이스 | 전적/통계 저장                    | SQLite      | `sqlite3` (Python 내장)       |

## 3. 프로젝트 상세 설계

### 3.1 게임 규칙 및 로직

| 항목         | 설명                                                                 |
|--------------|----------------------------------------------------------------------|
| 기본 체력    | 플레이어당 10                                                        |
| 공격 조건    | 좌 → 우로 자이로센서 휘두르기                                       |
| 방어 조건    | 아래 → 위로 자이로센서 휘두르기                                     |
| 방어 효과    | 방어 성공 시 0.2초간 공격 패링                                       |
| 판정 주기    | 0.2초마다 데이터 수신 및 판정                                        |
| 승패 조건    | 상대방 체력을 0으로 만들면 승리                                     |

### 3.2 서버 구성 (Raspberry Pi - Python)

#### 사용 언어 및 라이브러리

- 언어: Python
- 통신: ZeroMQ (`pyzmq`)
- 데이터베이스: SQLite (`sqlite3`)
- TUI: `curses` 또는 `npyscreen`

#### 주요 기능

| 기능                  | 설명 |
|-----------------------|------|
| 클라이언트 매칭 관리 | FIFO 방식으로 2명 대기 시 매치 생성 |
| 게임 로직 처리        | 공격/방어 판정, 체력 계산, 승패 판정 |
| 데이터베이스 연동     | 전적 저장 (닉네임, 체력, 공격/방어 성공 횟수) |
| TUI 출력              | 대기화면, 게임화면, 결과화면, 전적 조회 화면 |
| 닉네임 관리           | 클라이언트 IP → 사용자 지정 닉네임 매핑 |

### 3.3 클라이언트 구성 (ESP8266 - C/C++)

#### 사용 언어 및 라이브러리

- 언어: C / C++
- 센서: `Wire.h` (I2C), `Adafruit_MPU6050`
- 통신: WiFi (`ESP8266WiFi.h`), ZMQ 브리징 필요

#### 주요 기능

| 기능               | 설명 |
|--------------------|------|
| 자이로센서 수집    | MPU6050 또는 GY-521 사용, 각 축 회전값 수집 |
| 동작 인식          | 회전 방향 판별 (공격/방어) |
| 데이터 전송        | 실시간 자이로 데이터 → 서버 전송 |
| 게임 상태 수신     | 서버의 상태 메시지를 수신하여 반영 (옵션 기능) |

## 4. 통신 구조 (IPC 및 네트워크 흐름)

### 4.1 통신 방향

| 방향             | 설명                                 | 흐름 형태  |
|------------------|--------------------------------------|------------|
| 클라이언트 → 서버 | 자이로센서 데이터 전송 (공격/방어 신호) | 단방향     |
| 서버 → 클라이언트 | 게임 상태(체력, 판정 결과 등) 전송       | 단방향 또는 양방향 |

### 4.2 통신 흐름도

```
ESP8266 (C++)
   ↓ (공격/방어 데이터 전송) [ZMQ PUSH]
Raspberry Pi (Python)
   ↳ 처리: 판정 / 상태 갱신 / DB 저장
   ↓ (게임 상태 데이터 전송) [ZMQ PUB]
ESP8266 (C++) 
```

- 통신 프로토콜: TCP/IP 기반
- 포맷: JSON 혹은 고정 바이트 구조체

## 5. 데이터베이스 설계

| 테이블명      | 컬럼                             | 설명 |
|---------------|----------------------------------|------|
| `users`       | `id`, `nickname`, `ip`           | 클라이언트 식별 및 닉네임 관리 |
| `match_log`   | `match_id`, `user_id`, `hp`, `attack_success`, `defense_success`, `result` | 게임 전적 저장 |
| `connections` | `user_id`, `timestamp`, `status` | 접속 로그 기록용 |

## 6. 화면 구성 (서버 TUI)

| 화면        | 설명 |
|-------------|------|
| 메인화면     | \[매칭 시작\], \[닉네임 설정\] 메뉴 |
| 매칭 대기창  | 2명 접속 시 매칭 시작, 카운트다운 |
| 게임 화면    | 양 플레이어 체력 및 행동 로그 표시 |
| 결과화면     | 승자 출력 후 메인화면 복귀 |
| 닉네임 설정창 | 접속된 IP 목록 및 닉네임 입력 필드 제공 |

## 7. 프로젝트 개발 일정 (6일간)

| 날짜     | 작업 항목 |
|----------|-----------|
| 1일차 | 개발 환경 구성 (Raspberry Pi, ESP8266, PlatformIO)<br>ESP8266 자이로센서 테스트 (C++)<br>ZeroMQ 서버 기본 설정 |
| 2일차 | ZeroMQ 기반 클라이언트 ↔ 서버 통신 구현<br>DB 초기화 및 접속 로그 저장<br>간단한 클라이언트 매칭 대기 구조 구현 |
| 3일차 | 게임 판정 로직 구현 (HP 계산, 공격/방어 인식)<br>클라이언트 수신 처리 구현<br>서버 TUI 기본 출력 구현 |
| 4일차 | 매칭 시스템 구현 (FIFO)<br>게임 시작/종료 흐름 연동<br>클라이언트 동작별 데이터 송수신 연동 |
| 5일차 | 전적 저장 로직 구현<br>전적 조회 및 닉네임 설정 기능 구현<br>공격/방어 성공률 등 통계 출력 |
| 6일차 | 통합 테스트 및 버그 수정<br>코드 리팩토링 및 주석 추가<br>발표 자료 작성 |

## 8. 확장성 및 참고 사항

- 향후 다중 클라이언트 대응 및 스레드 분리 구조로 확장 가능
- GUI 기반 게임으로 발전 시 Pygame 또는 Qt 활용 고려
- 실제 ESP8266 통신 대신 Python 기반 가상 클라이언트를 통해 테스트 가능
